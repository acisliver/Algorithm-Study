## 1. 그래프를 표현하는 자료구조에 대해 설명하시오.


### 1. 인접 행렬 Adjacency Matrix

인접 행렬은 2차원 배열로 그래프를 구현하는 방식이다. 일반적으로 간선이 존재하는 두 정점은 칸은 1로 없는 칸은 0으로 채워주고 가중치가 다른 그래프라면 해당 가중치 값을 넣어준다.

- 2차원 배열상 그래프 정보가 모두 담겨있기 때문에 간선의 존재 여부나 가중치를 알고 싶을 때 바로 참조할 수 있다 → `O(1)`
- 하지만 N^2 크기의 2차원 배열을 사용하기 때문에 메모리가 필요 이상으로 많이 사용될 수 있다. (10000개의 정점으로 구성된 그래프 내에서 간선이 5개만 존재할 경우)
- 모든 간선 정보를 대입하는 데 시간이 걸린다 → `O(N^2)`
<br />

### 2. 인접 리스트 Adjacency List

인접 리스트는 정점에 연결되어 있는 정점들만 리스트로 나타내는 그래프 자료구조이다.

- 필요한 만큼의 메모리만 사용하기 때문에 메모리 낭비가 없다
- 정점들의 연결 정보를 확인하려 할 때는 간선의 갯수만큼의 탐색이 필요하다 → `O(N)` (N = 정점에 연결된 간선의 수)
- 탐색이 인접 행렬에 비해서는 오래 걸릴 수 있다. (모든 노드가 10000개 인데 1번 노드에 9999개의 간선이 존재하는 경우 9999번째 인접 정점을 확인하는데는 9999번의 탐색이 필요)
- 각 인접리스트에 대한 헤드포인터를 배열로 갖는다.
 
 <br />  <br /><br />
 
## 2. DFS를 구현하는 방법을 설명하시오.


  **깊이우선탐색**이다. 그래프에서 깊은 부분을 우선적으로 탐색한다.

  정점을 기준으로 간선이 연결되어 있는 정점 들 중 하나를 선택해 이동하고 다시 이동한 정점을 기준으로 다시 인접 정점을 선택한다. 연결되어있는 간선을 따라 찾고자 하는 정점을 만날 때 까지 진행하고 찾지 못하면 다시 이전 정점으로 돌아와 반복한다. 재귀함수를 통해서 구현하기도 하고 혹은 `Stack` 을 사용해 구현하기도 한다.

  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
  2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
  3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복한다.(재귀)

<br />  <br /><br />
      

## 3. BFS를 구현하는 방법을 설명하시오.

    
  넓이우선탐색이다.

  정점을 기준으로 간선이 연결되어 있는 모든 정점들을 차례로 방문하고 찾고자 하는 정점을 만날 때까지 반복한다. 일반적으로 `Queue` 를 사용하여 많이 구현한다.

  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
  2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모드 큐에 삽입하고 처리를 한다.
  3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

